{% extends "base.html" %}
{% block content %}
<div class="container my-5">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2>Kept / Removed — Playlist</h2>
        <a class="btn btn-secondary" href="{% url 'playlists.edit_by_id' playlist_id=playlist_id %}">Back to Edit</a>
    </div>

    <div class="row">
        <div class="col-md-6">
            <h4>Kept</h4>
            {% if kept %}
                <ul id="kept-list" class="list-group list-group-dark">
                {% for s in kept %}
                    <li class="list-group-item d-flex align-items-center kept-item" data-track-uri="{{ s.track_uri }}">
                        <img src="{{ s.image_url|default:'/static/img/placeholder.png' }}" alt="cover" style="width:56px; height:56px; object-fit:cover; margin-right:12px;"/>
                        <div>
                            <div class="fw-bold">{{ s.name }}</div>
                            <div class="text-muted small">{{ s.artists|join:', ' }}</div>
                        </div>
                        <div class="ms-auto d-flex align-items-center gap-2">
                            <a href="{{ s.spotify_url }}" class="btn btn-outline-spotify btn-sm btn-pill">Open</a>
                        </div>
                    </li>
                {% endfor %}
                </ul>
            {% else %}
                <p class="text-muted">No songs marked as kept yet.</p>
            {% endif %}
        </div>

        <div class="col-md-6">
            <h4>Removed</h4>
            {% if removed %}
                <ul id="removed-list" class="list-group list-group-dark">
                {% for s in removed %}
                    <li class="list-group-item d-flex align-items-center removed-item" data-track-uri="{{ s.track_uri }}">
                        <img src="{{ s.image_url|default:'/static/img/placeholder.png' }}" alt="cover" style="width:56px; height:56px; object-fit:cover; margin-right:12px;"/>
                        <div>
                            <div class="fw-bold">{{ s.name }}</div>
                            <div class="text-muted small">{{ s.artists|join:', ' }}</div>
                        </div>
                        <div class="ms-auto d-flex align-items-center gap-2">
                            <a href="{{ s.spotify_url }}" class="btn btn-outline-spotify btn-sm btn-pill">Open</a>
                            <button class="btn btn-spotify btn-sm btn-pill reconsider-btn" data-track-uri="{{ s.track_uri }}">Move to Kept</button>
                        </div>
                    </li>
                {% endfor %}
                </ul>
            {% else %}
                <p class="text-muted">No songs marked as removed yet.</p>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const removedList = document.getElementById('removed-list');
    let keptList = document.getElementById('kept-list');

    // helper to read CSRF token from cookie
    function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
    }

    // use event delegation on removed-list so dynamically moved items still work
    if (removedList) {
        removedList.addEventListener('click', async (ev) => {
            const btn = ev.target.closest('.reconsider-btn');
            if (!btn) return;

            ev.preventDefault();
            const li = btn.closest('.removed-item');
            const trackUri = btn.dataset.trackUri || btn.getAttribute('data-track-uri');
            const payload = { playlist_id: '{{ playlist_id }}', track_uri: trackUri };

            // disable button while in-flight
            btn.disabled = true;
            btn.textContent = 'Working...';

            try {
                const resp = await fetch("{% url 'playlists.reconsider_decision' %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(payload)
                });

                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    console.error('reconsider failed', resp.status, data);
                    throw new Error('reconsider failed');
                }

                // move DOM node from removed-list to kept-list
                if (li) {
                    const removedUl = li.parentNode;
                    // Prepare kept list container
                    let keptUl = document.getElementById('kept-list');
                    if (!keptUl) {
                        // Create UL in the left column if it doesn't exist
                        const keptCol = document.querySelectorAll('.row > .col-md-6')[0];
                        if (keptCol) {
                            // remove any placeholder paragraph
                            const p = keptCol.querySelector('p.text-muted');
                            if (p) p.remove();
                            keptUl = document.createElement('ul');
                            keptUl.id = 'kept-list';
                            keptUl.className = 'list-group list-group-dark';
                            keptCol.appendChild(keptUl);
                        }
                    }

                    // Adjust li classes and actions
                    li.classList.remove('removed-item');
                    li.classList.add('kept-item');
                    const actions = li.querySelector('.ms-auto');
                    if (actions) {
                        // Remove reconsider button
                        const reconsider = actions.querySelector('.reconsider-btn');
                        if (reconsider) reconsider.remove();
                        // Ensure Open button uses theme
                        const openBtn = actions.querySelector('a.btn');
                        if (openBtn) openBtn.className = 'btn btn-outline-spotify btn-sm btn-pill';
                    }

                    keptUl && keptUl.appendChild(li);

                    // if removed list is empty now, show placeholder in removed column
                    if (removedUl && removedUl.children.length === 0) {
                        const removedCol = document.querySelectorAll('.row > .col-md-6')[1];
                        if (removedCol) {
                            removedUl.remove();
                            const placeholder = document.createElement('p');
                            placeholder.className = 'text-muted';
                            placeholder.textContent = 'No songs marked as removed yet.';
                            removedCol.appendChild(placeholder);
                        }
                    }
                }

                // Optionally show a small success indicator
                // alert('Song returned to unedited pool');

            } catch (err) {
                console.error('Failed to reconsider removed track', err);
                alert('Could not move song to Kept — try again.');
                btn.disabled = false;
                btn.textContent = 'Move to Kept';
            }
        });
    }
});
</script>
<style>
/* legacy kept-action-btn styles removed; using theme buttons */
</style>
{% endblock %}
